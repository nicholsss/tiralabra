<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AldousBroder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mazegenerator</a> &gt; <a href="index.source.html" class="el_package">domain</a> &gt; <span class="el_source">AldousBroder.java</span></div><h1>AldousBroder.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import util.Cell;

/**
 *
 * @author nicholas
 */
public class AldousBroder {

    private Cell[][] grid;
    List&lt;Cell&gt; neighbours;
    int rows;
    int cols;
    int iteration;

    /**
     *
     * @param rows amount of rows for grid
     * @param cols amount of cols for grid
     */
<span class="fc" id="L30">    public AldousBroder(int rows, int cols) {</span>
<span class="fc" id="L31">        this.rows = rows;</span>
<span class="fc" id="L32">        this.cols = cols;</span>

<span class="fc" id="L34">        grid = new Cell[this.rows][this.cols];</span>

<span class="fc bfc" id="L36" title="All 2 branches covered.">        for (int i = 0; i &lt; this.rows; i++) {</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">            for (int j = 0; j &lt; this.cols; j++) {</span>
<span class="fc" id="L38">                grid[i][j] = new Cell(i, j);</span>
            }
        }

<span class="fc" id="L42">    }</span>

    /**
     * Generate maze, when visitedCells, is same as rows * cols amount,
     * algorithm stops, because all cells have been visited by then.
     *
     * @return generated grid
     */
    public Cell[][] generateMaze() {
<span class="fc" id="L51">        long rx = System.nanoTime() % this.rows;</span>
<span class="fc" id="L52">        long ry = System.nanoTime() % this.cols;</span>
<span class="fc" id="L53">        int done = this.cols * this.rows;</span>

        //counter to keep track when all cells all visited
<span class="fc" id="L56">        int visitedCells = 1;</span>

<span class="fc" id="L58">        Cell current = grid[(int) rx][(int) ry];</span>
<span class="fc" id="L59">        current.setVisited();</span>

<span class="fc bfc" id="L61" title="All 2 branches covered.">        while (visitedCells != done) {</span>

<span class="fc" id="L63">            Cell next = checkNeighbour(current);</span>

            //if current cell neighbour is not visited, go there and mark it as
            //visited and remowe walls
<span class="fc bfc" id="L67" title="All 2 branches covered.">            if (next.getVisited() == false) {</span>
<span class="fc" id="L68">                next.setVisited();</span>
<span class="fc" id="L69">                iteration++;</span>
<span class="fc" id="L70">                current.removeWalls(next);</span>
<span class="fc" id="L71">                visitedCells++;</span>
            }
<span class="fc" id="L73">            current = next;</span>

<span class="fc" id="L75">        }</span>
<span class="fc" id="L76">        return grid;</span>
    }

    /**
     * Check if cell has neighbors inside grid
     *
     * @param current cell which contains information about current cell
     * @return
     */
    public Cell checkNeighbour(Cell current) {
<span class="fc" id="L86">        neighbours = new ArrayList&lt;Cell&gt;();</span>

<span class="fc" id="L88">        int x = current.getX();</span>
<span class="fc" id="L89">        int y = current.getY();</span>

<span class="fc" id="L91">        Cell cell = null;</span>

        // check top neighbor
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (x - 1 != -1) {</span>

<span class="fc" id="L96">            neighbours.add(grid[x - 1][y]);</span>
        }

        //Check current cell right neighbour
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (y + 1 != cols) {</span>

<span class="fc" id="L102">            neighbours.add(grid[x][y + 1]);</span>

        }
        //Check current cell bottom neighbour
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (x + 1 != rows) {</span>

<span class="fc" id="L108">            neighbours.add(grid[x + 1][y]);</span>
        }
        //Check current cell left neighbour
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (y - 1 != -1) {</span>

<span class="fc" id="L113">            neighbours.add(grid[x][y - 1]);</span>
        }

        // if there is over 0 neighbour choose one of them randomly.
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (neighbours.size() &gt; 0) {</span>
<span class="fc" id="L118">            cell = neighbours.get(new Random().nextInt(neighbours.size()));</span>

        }

<span class="fc" id="L122">        return cell;</span>
    }

    public void draw() {

<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (int i = 0; i &lt; rows; i++) {</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">            for (int j = 0; j &lt; cols; j++) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                if (grid[i][j].getTop() == true) {</span>
<span class="nc" id="L131">                    System.out.print(&quot;+---&quot;);</span>
                } else {
<span class="nc" id="L133">                    System.out.print(&quot;+   &quot;);</span>
                }

            }
<span class="nc" id="L137">            System.out.println(&quot;+&quot;);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            for (int j = 0; j &lt; cols; j++) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                if (grid[i][j].getLeft() == true) {</span>
<span class="nc" id="L140">                    System.out.print(&quot;|   &quot;);</span>
                } else {
<span class="nc" id="L142">                    System.out.print(&quot;    &quot;);</span>
                }

            }
<span class="nc" id="L146">            System.out.println(&quot;|&quot;);</span>

        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (int j = 0; j &lt; cols; j++) {</span>
<span class="nc" id="L150">            System.out.print(&quot;+---&quot;);</span>
        }
<span class="nc" id="L152">        System.out.println(&quot;+&quot;);</span>
<span class="nc" id="L153">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>