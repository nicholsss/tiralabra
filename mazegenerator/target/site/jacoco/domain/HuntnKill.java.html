<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HuntnKill.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mazegenerator</a> &gt; <a href="index.source.html" class="el_package">domain</a> &gt; <span class="el_source">HuntnKill.java</span></div><h1>HuntnKill.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import util.Cell;

/**
 *
 * @author nicholas
 */
public class HuntnKill {

    private Cell[][] grid;
    List&lt;Cell&gt; neighbours;
    List&lt;Cell&gt; visitedNeighbour;
    int rows;
    int cols;

<span class="fc" id="L25">    public HuntnKill(int rows, int cols) {</span>

<span class="fc" id="L27">        this.rows = rows;</span>
<span class="fc" id="L28">        this.cols = cols;</span>

<span class="fc" id="L30">        grid = new Cell[this.rows][this.cols];</span>

<span class="fc bfc" id="L32" title="All 2 branches covered.">        for (int i = 0; i &lt; this.rows; i++) {</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">            for (int j = 0; j &lt; this.cols; j++) {</span>
<span class="fc" id="L34">                grid[i][j] = new Cell(i, j);</span>
            }
        }

<span class="fc" id="L38">    }</span>

    public Cell[][] generateMaze() {
<span class="fc" id="L41">        Random ran = new Random();</span>
<span class="fc" id="L42">        long rx = System.nanoTime() % this.rows;</span>
<span class="fc" id="L43">        long ry = System.nanoTime() % this.cols;</span>
<span class="fc" id="L44">        Cell current = grid[(int) rx][(int) ry];</span>

<span class="fc" id="L46">        current.setVisited();</span>

<span class="fc bfc" id="L48" title="All 2 branches covered.">        while (current != null) {</span>

<span class="fc" id="L50">            Cell next = checkValidNeighbours(current);</span>

            // if cell is not null, visit it, and remove walls between current
            // and next cell
<span class="fc bfc" id="L54" title="All 2 branches covered.">            if (next != null) {</span>
<span class="fc" id="L55">                next.setVisited();</span>
<span class="fc" id="L56">                current.removeWalls(next);</span>
<span class="fc" id="L57">                current = next;</span>

            } else {

                // if cell doesnt have neighbour, start looking unvisited cell from
                // top row to bottom row until found unvisited cell.
                // When cell found visit it, and remove walls between found cell
                // and already visited cell
                loop:
<span class="fc bfc" id="L66" title="All 2 branches covered.">                for (int i = 0; i &lt; this.rows; i++) {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">                    for (int j = 0; j &lt; this.cols; j++) {</span>
<span class="fc" id="L68">                        current = null;</span>

<span class="fc bfc" id="L70" title="All 2 branches covered.">                        if (grid[i][j].getVisited() == false) {</span>
<span class="fc" id="L71">                            current = grid[i][j];</span>
<span class="fc" id="L72">                            current.setVisited();</span>

<span class="fc" id="L74">                            Cell prev = checkNeighbour(current);</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">                            if (prev != null) {</span>
<span class="fc" id="L76">                                prev.removeWalls(current);</span>
                            }

                            //This breaks algorithm if x, y too big.
                            break loop;
                        }

                    }
                }
            }

<span class="fc" id="L87">        }</span>
<span class="fc" id="L88">        return grid;</span>
    }

    public Cell[][] getGrid() {
<span class="fc" id="L92">        return grid;</span>
    }

    /**
     * Check neighbor which are in grid, and also not visited
     *
     * @param current cell used to check it's neighbors
     * @return
     */
    public Cell checkValidNeighbours(Cell current) {
<span class="fc" id="L102">        neighbours = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L103">        int x = current.getX();</span>
<span class="fc" id="L104">        int y = current.getY();</span>

<span class="fc" id="L106">        Cell cell = null;</span>
        //top
<span class="fc bfc" id="L108" title="All 4 branches covered.">        if (x - 1 != -1 &amp;&amp; !grid[x - 1][y].getVisited()) {</span>

<span class="fc" id="L110">            neighbours.add(grid[x - 1][y]);</span>
        }

        //Check current cell right neighbour
<span class="fc bfc" id="L114" title="All 4 branches covered.">        if (y + 1 != cols &amp;&amp; !grid[x][y + 1].getVisited()) {</span>

<span class="fc" id="L116">            neighbours.add(grid[x][y + 1]);</span>

        }
        //Check current cell bottom neighbour
<span class="fc bfc" id="L120" title="All 4 branches covered.">        if (x + 1 != rows &amp;&amp; !grid[x + 1][y].getVisited()) {</span>

<span class="fc" id="L122">            neighbours.add(grid[x + 1][y]);</span>
        }
        //Check current cell left neighbour
<span class="fc bfc" id="L125" title="All 4 branches covered.">        if (y - 1 != -1 &amp;&amp; !grid[x][y - 1].getVisited()) {</span>

<span class="fc" id="L127">            neighbours.add(grid[x][y - 1]);</span>
        }

        // if there is over 0 neighbour choose one of them randomly.
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (neighbours.size() &gt; 0) {</span>
<span class="fc" id="L132">            cell = neighbours.get(new Random().nextInt(neighbours.size()));</span>

        }

<span class="fc" id="L136">        return cell;</span>

    }

    /**
     * Check current cell all visited neighbors so walls can be removed from
     * visited cell and current cell.
     *
     * @param current unvisited cell from grid
     * @return cell which is next to current cell
     */
    public Cell checkNeighbour(Cell current) {
<span class="fc" id="L148">        visitedNeighbour = new ArrayList&lt;Cell&gt;();</span>

<span class="fc" id="L150">        int x = current.getX();</span>
<span class="fc" id="L151">        int y = current.getY();</span>

<span class="fc" id="L153">        Cell cell = null;</span>

<span class="pc bpc" id="L155" title="1 of 4 branches missed.">        if (x - 1 != -1 &amp;&amp; grid[x - 1][y].getVisited()) {</span>

<span class="fc" id="L157">            visitedNeighbour.add(grid[x - 1][y]);</span>
        }

        //Check current cell right neighbour
<span class="fc bfc" id="L161" title="All 4 branches covered.">        if (y + 1 != cols &amp;&amp; grid[x][y + 1].getVisited()) {</span>

<span class="fc" id="L163">            visitedNeighbour.add(grid[x][y + 1]);</span>

        }
        //Check current cell bottom neighbour
<span class="fc bfc" id="L167" title="All 4 branches covered.">        if (x + 1 != rows &amp;&amp; grid[x + 1][y].getVisited()) {</span>

<span class="fc" id="L169">            visitedNeighbour.add(grid[x + 1][y]);</span>
        }
        //Check current cell left neighbour
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">        if (y - 1 != -1 &amp;&amp; grid[x][y - 1].getVisited()) {</span>

<span class="fc" id="L174">            visitedNeighbour.add(grid[x][y - 1]);</span>
        }

        // if there is over 0 neighbour choose one of them randomly.
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (visitedNeighbour.size() &gt; 0) {</span>
<span class="fc" id="L179">            cell = visitedNeighbour.get(new Random().nextInt(visitedNeighbour.size()));</span>

        }

<span class="fc" id="L183">        return cell;</span>

    }

    public void draw() {

<span class="nc bnc" id="L189" title="All 2 branches missed.">        for (int i = 0; i &lt; rows; i++) {</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">            for (int j = 0; j &lt; cols; j++) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (grid[i][j].getTop() == true) {</span>
<span class="nc" id="L193">                    System.out.print(&quot;+---&quot;);</span>
                } else {
<span class="nc" id="L195">                    System.out.print(&quot;+   &quot;);</span>
                }

            }
<span class="nc" id="L199">            System.out.println(&quot;+&quot;);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            for (int j = 0; j &lt; cols; j++) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (grid[i][j].getLeft() == true) {</span>
<span class="nc" id="L202">                    System.out.print(&quot;|   &quot;);</span>
                } else {
<span class="nc" id="L204">                    System.out.print(&quot;    &quot;);</span>
                }

            }
<span class="nc" id="L208">            System.out.println(&quot;|&quot;);</span>

        }
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (int j = 0; j &lt; cols; j++) {</span>
<span class="nc" id="L212">            System.out.print(&quot;+---&quot;);</span>
        }
<span class="nc" id="L214">        System.out.println(&quot;+&quot;);</span>
<span class="nc" id="L215">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>